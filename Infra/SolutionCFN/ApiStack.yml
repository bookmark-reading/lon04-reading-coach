AWSTemplateFormatVersion: "2010-09-09"
Description: "ApiStack (CFN-only): HTTP API + Cognito JWT + inline python3.12 Lambdas + /health"

Parameters:
  # From AuthStack
  UserPoolClientId:
    Type: String
    Description: "JWT audience (Cognito app client id)"
  UserPoolIssuerUrl:
    Type: String
    Description: "JWT issuer (Cognito user pool issuer URL)"

  # From DataStack
  BooksBucketName:
    Type: String
    Description: "S3 bucket storing PDF books"
  BooksTableName:
    Type: String
    Description: "DynamoDB Books table name"
  UserProfilesTableName:
    Type: String
    Description: "DynamoDB UserProfiles table name"

Resources:
  #########################################################
  # HTTP API
  # - MVP CORS for local UI; tighten later
  #########################################################
  HttpApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: "BookmarkReadingApi"
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins: ["http://localhost:3000"]
        AllowMethods: ["GET", "PUT", "OPTIONS"]
        AllowHeaders: ["authorization", "content-type"]

  DefaultStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref HttpApi
      StageName: "$default"
      AutoDeploy: true

  #########################################################
  # JWT authorizer (Cognito)
  # - validates issuer + audience
  #########################################################
  JwtAuthorizer:
    Type: AWS::ApiGatewayV2::Authorizer
    Properties:
      ApiId: !Ref HttpApi
      AuthorizerType: JWT
      Name: "CognitoJwt"
      IdentitySource: ["$request.header.Authorization"]
      JwtConfiguration:
        Issuer: !Ref UserPoolIssuerUrl
        Audience: [!Ref UserPoolClientId]

  #########################################################
  # Shared Lambda role
  # - logs
  # - DynamoDB (profiles + books)
  # - S3 GetObject (needed for presigned URL to work)
  #########################################################
  ApiLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ApiLambdaRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: LogsPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: ["logs:CreateLogGroup","logs:CreateLogStream","logs:PutLogEvents"]
                Resource: "*"

        - PolicyName: DynamoDbPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: ["dynamodb:GetItem","dynamodb:PutItem"]
                Resource: !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${UserProfilesTableName}"
              - Effect: Allow
                Action: ["dynamodb:GetItem","dynamodb:Query"]
                Resource:
                  - !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${BooksTableName}"
                  - !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${BooksTableName}/index/*"

        - PolicyName: S3Policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: ["s3:GetObject"]
                Resource: !Sub "arn:aws:s3:::${BooksBucketName}/*"

  #########################################################
  # Lambdas (physical name == logical name)
  #########################################################

  HealthFunctionLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: HealthFunctionLambda
      Role: !GetAtt ApiLambdaRole.Arn
      Runtime: python3.12
      Handler: index.handler
      Timeout: 5
      Code:
        ZipFile: |
          import json
          def handler(event, context):
            # Public liveness probe (no auth / no dependencies).
            return {"statusCode":200,"headers":{"content-type":"application/json"},"body":json.dumps({"ok":True})}

  ProfileFunctionLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: ProfileFunctionLambda
      Role: !GetAtt ApiLambdaRole.Arn
      Runtime: python3.12
      Handler: index.handler
      Timeout: 10
      Environment:
        Variables:
          USER_TABLE: !Ref UserProfilesTableName
      Code:
        ZipFile: |
          import os, json, boto3
          from decimal import Decimal

          # Profiles table: PK=userId (Cognito 'sub')
          T = os.environ["USER_TABLE"]
          d = boto3.resource("dynamodb").Table(T)

          def uid(e):
            # Claims injected by HTTP API JWT authorizer
            rc = e.get("requestContext") or {}
            a = rc.get("authorizer") or {}
            j = a.get("jwt") or {}
            c = j.get("claims") or {}
            return c.get("sub")

          def _json_default(o):
            # DynamoDB returns numbers as Decimal; convert to JSON-safe types.
            if isinstance(o, Decimal):
              return int(o) if o % 1 == 0 else float(o)
            raise TypeError(f"Object of type {o.__class__.__name__} is not JSON serializable")

          def resp(s, b):
            return {"statusCode": s, "headers": {"content-type": "application/json"}, "body": json.dumps(b, default=_json_default)}

          def handler(event, context):
            u = uid(event)
            if not u:
              return {"statusCode": 401, "body": "Unauthorized"}

            m = ((event.get("requestContext") or {}).get("http") or {}).get("method", "")

            if m == "GET":
              it = (d.get_item(Key={"userId": u}).get("Item")) or {"userId": u}
              return resp(200, it)

            if m == "PUT":
              b = json.loads(event.get("body") or "{}")
              it = {"userId": u, "firstName": b.get("firstName"), "lastName": b.get("lastName"), "grade": b.get("grade")}
              d.put_item(Item=it)
              return resp(200, it)

            return {"statusCode": 405, "body": "Method Not Allowed"}

  ListBooksFunctionLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: ListBooksFunctionLambda
      Role: !GetAtt ApiLambdaRole.Arn
      Runtime: python3.12
      Handler: index.handler
      Timeout: 10
      Environment:
        Variables:
          USER_TABLE: !Ref UserProfilesTableName
          BOOKS_TABLE: !Ref BooksTableName
          BOOKS_GSI: "GradeIndex"
      Code:
        ZipFile: |
          import os, json, boto3
          from decimal import Decimal
          from boto3.dynamodb.conditions import Key

          # Reads user grade then queries Books via GradeIndex (PK=grade)
          U = boto3.resource("dynamodb").Table(os.environ["USER_TABLE"])
          B = boto3.resource("dynamodb").Table(os.environ["BOOKS_TABLE"])
          G = os.environ.get("BOOKS_GSI", "GradeIndex")

          def uid(e):
            rc = e.get("requestContext") or {}
            a = rc.get("authorizer") or {}
            j = a.get("jwt") or {}
            c = j.get("claims") or {}
            return c.get("sub")

          def _json_default(o):
            # DynamoDB returns numbers as Decimal; convert to JSON-safe types.
            if isinstance(o, Decimal):
              return int(o) if o % 1 == 0 else float(o)
            raise TypeError(f"Object of type {o.__class__.__name__} is not JSON serializable")

          def handler(event, context):
            u = uid(event)
            if not u:
              return {"statusCode": 401, "body": "Unauthorized"}

            p = (U.get_item(Key={"userId": u}).get("Item")) or {}
            gr = p.get("grade")
            if gr is None:
              return {"statusCode": 400, "body": "User profile is missing grade"}

            res = B.query(IndexName=G, KeyConditionExpression=Key("grade").eq(gr))
            items = res.get("Items") or []
            return {"statusCode": 200, "headers": {"content-type": "application/json"}, "body": json.dumps(items, default=_json_default)}

  GetBookUrlFunctionLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: GetBookUrlFunctionLambda
      Role: !GetAtt ApiLambdaRole.Arn
      Runtime: python3.12
      Handler: index.handler
      Timeout: 10
      Environment:
        Variables:
          BOOKS_BUCKET: !Ref BooksBucketName
          BOOKS_TABLE: !Ref BooksTableName
          URL_TTL_SECONDS: "3600"
      Code:
        ZipFile: |
          import os, json, boto3
          from decimal import Decimal

          # Fetches book.s3Key then returns a presigned S3 URL (1 hour).
          bb = os.environ["BOOKS_BUCKET"]
          bt = os.environ["BOOKS_TABLE"]
          ttl = int(os.environ.get("URL_TTL_SECONDS", "3600"))
          d = boto3.resource("dynamodb").Table(bt)
          s3 = boto3.client("s3")

          def _json_default(o):
            if isinstance(o, Decimal):
              return int(o) if o % 1 == 0 else float(o)
            raise TypeError(f"Object of type {o.__class__.__name__} is not JSON serializable")

          def handler(event, context):
            bid = (event.get("pathParameters") or {}).get("bookId")
            if not bid:
              return {"statusCode": 400, "body": "Missing bookId"}

            it = (d.get_item(Key={"bookId": bid}).get("Item"))
            if not it or not it.get("s3Key"):
              return {"statusCode": 404, "body": "Book not found"}

            url = s3.generate_presigned_url("get_object", Params={"Bucket": bb, "Key": it["s3Key"]}, ExpiresIn=ttl)
            return {"statusCode": 200, "headers": {"content-type": "application/json"}, "body": json.dumps({"url": url, "expiresInSeconds": ttl}, default=_json_default)}


  HealthIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt HealthFunctionLambda.Arn
      PayloadFormatVersion: "2.0"

  ProfileIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt ProfileFunctionLambda.Arn
      PayloadFormatVersion: "2.0"

  ListBooksIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt ListBooksFunctionLambda.Arn
      PayloadFormatVersion: "2.0"

  GetBookUrlIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt GetBookUrlFunctionLambda.Arn
      PayloadFormatVersion: "2.0"

  #########################################################
  # Routes
  #########################################################
  HealthRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "GET /health"
      AuthorizationType: NONE
      Target: !Sub "integrations/${HealthIntegration}"

  ProfileGetRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "GET /profile"
      AuthorizationType: JWT
      AuthorizerId: !Ref JwtAuthorizer
      Target: !Sub "integrations/${ProfileIntegration}"

  ProfilePutRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "PUT /profile"
      AuthorizationType: JWT
      AuthorizerId: !Ref JwtAuthorizer
      Target: !Sub "integrations/${ProfileIntegration}"

  ListBooksRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "GET /books"
      AuthorizationType: JWT
      AuthorizerId: !Ref JwtAuthorizer
      Target: !Sub "integrations/${ListBooksIntegration}"

  GetBookUrlRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "GET /books/{bookId}/url"
      AuthorizationType: JWT
      AuthorizerId: !Ref JwtAuthorizer
      Target: !Sub "integrations/${GetBookUrlIntegration}"

  #########################################################
  # Invoke permissions (API -> Lambda)
  #########################################################
  HealthInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref HealthFunctionLambda
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${HttpApi}/*/*/*"

  ProfileInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ProfileFunctionLambda
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${HttpApi}/*/*/*"

  ListBooksInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ListBooksFunctionLambda
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${HttpApi}/*/*/*"

  GetBookUrlInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref GetBookUrlFunctionLambda
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${HttpApi}/*/*/*"

Outputs:
  ApiBaseUrl:
    Value: !Sub "https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com"
    Description: "Base URL for the HTTP API"
